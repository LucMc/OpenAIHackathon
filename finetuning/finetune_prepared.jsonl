{"prompt":"# Make this code more efficient\ndef sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n###\n\n","completion":" def partition(array, low, high):\n    pivot = array[high]\n    i = low - 1\n  \n    for j in range(low, high):\n        if array[j] <= pivot:\n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n  \n            # Swapping element at i with element at j\n            (array[i], array[j]) = (array[j], array[i])\n  \n    (array[i + 1], array[high]) = (array[high], array[i + 1])\n  \n    return i + 1\n  \ndef quick_sort(array, low, high):\n    if low < high:\n        pi = partition(array, low, high)\n        quick_sort(array, low, pi - 1)\n        quick_sort(array, pi + 1, high)\n\ndef sort(arr):\n    return quick_sort(array, 0, len(array) - 1)"}
{"prompt":"\/\/ Make this code more efficient\nvoid sort(int arr[], int n)\n{\n    int i, j;\n    for (i = 0; i < n - 1; i++)\n \n        \/\/ Last i elements are already\n        \/\/ in place\n        for (j = 0; j < n - i - 1; j++)\n            if (arr[j] > arr[j + 1])\n                swap(arr[j], arr[j + 1]);\n}\n\n###\n\n","completion":" void swap(int* a, int* b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n  \n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high]; \/\/ pivot\n    int i\n        = (low\n           - 1); \/\/ Index of smaller element and indicates\n                 \/\/ the right position of pivot found so far\n  \n    for (int j = low; j <= high - 1; j++) {\n        \/\/ If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            i++; \/\/ increment index of smaller element\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n  \nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high) {\n        \/* pi is partitioning index, arr[p] is now\n        at right place *\/\n        int pi = partition(arr, low, high);\n  \n        \/\/ Separately sort elements before\n        \/\/ partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid sort(int arr[], int n)\n{\n    quickSort(arr, 0, n - 1);\n}"}
{"prompt":"\/\/ Make this code more efficient\nfunction swap(arr, xp, yp)\n{\n    var temp = arr[xp];\n    arr[xp] = arr[yp];\n    arr[yp] = temp;\n}\n \nfunction sort( arr, n)\n{\n    var i, j;\n    for (i = 0; i < n-1; i++)\n    {\n        for (j = 0; j < n-i-1; j++)\n        {\n            if (arr[j] > arr[j+1])\n            {\n            swap(arr,j,j+1);\n            \n            }\n        }\n    \n    }\n}\n\n###\n\n","completion":" function swap(arr, i, j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction partition(arr, low, high) {\n    let pivot = arr[high];\n    let i = (low - 1);\n  \n    for (let j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i + 1, high);\n    return (i + 1);\n}\n\nfunction quickSort(arr, low, high) {\n    if (low < high) {\n        let pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nfunction sort( arr, n)\n{\n    quickSort(arr, 0, n - 1);\n}"}
