{"prompt":"# Make this code more efficient\ndef sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n###\n\n","completion":"def partition(array, low, high):\n    pivot = array[high]\n    i = low - 1\n  \n    for j in range(low, high):\n        if array[j] <= pivot:\n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n  \n            # Swapping element at i with element at j\n            (array[i], array[j]) = (array[j], array[i])\n  \n    (array[i + 1], array[high]) = (array[high], array[i + 1])\n  \n    return i + 1\n  \ndef quick_sort(array, low, high):\n    if low < high:\n        pi = partition(array, low, high)\n        quick_sort(array, low, pi - 1)\n        quick_sort(array, pi + 1, high)\n\ndef sort(arr):\n    return quick_sort(array, 0, len(array) - 1) END"}
{"prompt":"\/\/ Make this code more efficient\nvoid sort(int arr[], int n)\n{\n    int i, j;\n    for (i = 0; i < n - 1; i++)\n \n        \/\/ Last i elements are already\n        \/\/ in place\n        for (j = 0; j < n - i - 1; j++)\n            if (arr[j] > arr[j + 1])\n                swap(arr[j], arr[j + 1]);\n}\n\n###\n\n","completion":"void swap(int* a, int* b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n  \n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high]; \/\/ pivot\n    int i\n        = (low\n           - 1); \/\/ Index of smaller element and indicates\n                 \/\/ the right position of pivot found so far\n  \n    for (int j = low; j <= high - 1; j++) {\n        \/\/ If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            i++; \/\/ increment index of smaller element\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n  \nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high) {\n        \/* pi is partitioning index, arr[p] is now\n        at right place *\/\n        int pi = partition(arr, low, high);\n  \n        \/\/ Separately sort elements before\n        \/\/ partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid sort(int arr[], int n)\n{\n    quickSort(arr, 0, n - 1);\n} END"}
{"prompt":"\/\/ Make this code more efficient\nfunction swap(arr, xp, yp)\n{\n    var temp = arr[xp];\n    arr[xp] = arr[yp];\n    arr[yp] = temp;\n}\n \nfunction sort( arr, n)\n{\n    var i, j;\n    for (i = 0; i < n-1; i++)\n    {\n        for (j = 0; j < n-i-1; j++)\n        {\n            if (arr[j] > arr[j+1])\n            {\n            swap(arr,j,j+1);\n            \n            }\n        }\n    \n    }\n}\n\n###\n\n","completion":"function swap(arr, i, j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction partition(arr, low, high) {\n    let pivot = arr[high];\n    let i = (low - 1);\n  \n    for (let j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i + 1, high);\n    return (i + 1);\n}\n\nfunction quickSort(arr, low, high) {\n    if (low < high) {\n        let pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nfunction sort( arr, n)\n{\n    quickSort(arr, 0, n - 1);\n} END"}
{"prompt":"# Make this code more efficient\ndef gradient_descent(x, d, mu, N_epochs):\n    N = len(x)\n    f = 2 \/ N\n\n    #Empty predictions, errors, weights, gradients.\n    y = [0] * N\n    w = [0, 0]\n    grad = [0, 0]\n\n    for _ in it.repeat(None, N_epochs):\n        # Can\"t use a generator because we need to\n        # access its elements twice.\n        err = tuple(i - j for i, j in zip(d, y))\n        grad[0] = f * sum(err)\n        grad[1] = f * sum(i * j for i, j in zip(err, x))\n        w = [i + mu * j for i, j in zip(w, grad)]\n        y = (w[0] + w[1] * i for i in x)\n    return w\n\n###\n\n","completion":"def gradient_descent(x, d, mu, N_epochs):\n    d = d.squeeze()\n    N = len(x)\n    f = 2 \/ N\n\n    y = np.zeros(N)\n    err = np.zeros(N)\n    w = np.zeros(2)\n    grad = np.empty(2)\n\n    for _ in it.repeat(None, N_epochs):\n        np.subtract(d, y, out=err)\n        grad[:] = f * np.sum(err), f * (err @ x)\n        w = w + mu * grad\n        y = w[0] + w[1] * x\n    return w END"}
{"prompt":"\/\/ Make this code more efficient\nfor(let i=0; i < myArray.length; i++){\n}\n\n###\n\n","completion":"let len=myArray.length;\nfor(let i=0; i < len; i++){\n} END"}
{"prompt":"\/\/ Make this code more efficient\nstring First = \"A\";\nfor (int i = 0; i < 500; i++)\n{\n    First = First + \"A\";\n}\n\n###\n\n","completion":"StringBuilder sb = new StringBuilder(\"A\");\n        for (int i = 0; i < 500; i++)\n        {\n            sb.Append(\"A\");\n        } END"}
{"prompt":"\/\/ Make this code more efficient\npublic List<int> Sort(List<int> list)\n{\n    int iteration = 0;\n    while (!IsSorted(list))\n    {\n        PrintIteration(list, iteration);\n        list = Shuffle(list); \/\/Shuffle the numbers randomly\n        iteration++;\n    }\n\n    return list;\n}\n\nprivate bool IsSorted(List<int> list)\n{\n    for (int i = 0; i < list.Count - 1; i++)\n    {\n        if (list[i] > list[i + 1])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nprivate List<int> Shuffle(List<int> numbers)\n{\n    Random r = new Random();\n    for (int n = numbers.Count - 1; n > 0; --n)\n    {\n        int k = r.Next(n + 1);\n        int temp = numbers[n];\n        numbers[n] = numbers[k];\n        numbers[k] = temp;\n    }\n    return numbers;\n}\n\n###\n\n","completion":"public List<int> Sort(List<int> list)\n{\n    var array = list.ToArray()\n    int[] left;\n    int[] right;\n    int[] result = new int[array.Length];  \n    if (array.Length <= 1)\n        return array;              \n    int midPoint = array.Length \/ 2;  \n    left = new int[midPoint];\n\n    if (array.Length % 2 == 0)\n        right = new int[midPoint];  \n    else\n        right = new int[midPoint + 1];  \n    for (int i = 0; i < midPoint; i++)\n        left[i] = array[i];  \n    int x = 0;\n    for (int i = midPoint; i < array.Length; i++)\n    {\n        right[x] = array[i];\n        x++;\n    } \n\n    left = mergeSort(left);\n    right = mergeSort(right);\n    result = merge(left, right);  \n    return result.ToList();\n}\n\nprivate int[] merge(int[] left, int[] right)\n{\n    int resultLength = right.Length + left.Length;\n    int[] result = new int[resultLength];\n    int indexLeft = 0, indexRight = 0, indexResult = 0;  \n    while (indexLeft < left.Length || indexRight < right.Length)\n    {\n        if (indexLeft < left.Length && indexRight < right.Length)  \n        {  \n            if (left[indexLeft] <= right[indexRight])\n            {\n                result[indexResult] = left[indexLeft];\n                indexLeft++;\n                indexResult++;\n            }\n            else\n            {\n                result[indexResult] = right[indexRight];\n                indexRight++;\n                indexResult++;\n            }\n        }\n        else if (indexLeft < left.Length)\n        {\n            result[indexResult] = left[indexLeft];\n            indexLeft++;\n            indexResult++;\n        }\n        else if (indexRight < right.Length)\n        {\n            result[indexResult] = right[indexRight];\n            indexRight++;\n            indexResult++;\n        }  \n    }\n    return result;\n} END"}
{"prompt":"# Make this code more efficient\nlist1 = range(size)\nlist2 = range(size)\nresult = [(a * b) for a, b in zip(list1, list2)]\n\n###\n\n","completion":"array1 = numpy.arange(size) \narray2 = numpy.arange(size)\nresult = resultantArray = array1 * array2 END"}
{"prompt":"# Make this code more efficient\nmath.log(10)\n\n###\n\n","completion":"np.log(10) END"}
{"prompt":"# Make this code more efficient\nmath.exp(3)\n\n###\n\n","completion":"np.exp(3) END"}
{"prompt":"# Make this code more efficient\nrandom.gauss(0, 1)\n\n###\n\n","completion":"np.random.normal() END"}
{"prompt":"# Make this code more efficient\nrandom.choices([1,2,3], k=1)\n\n###\n\n","completion":"np.random.choice([1,2,3], size=1) END"}
{"prompt":"# Make this code more efficient\narr = np.array([1,2,3])\nrandom.choices(arr, k=1)\n\n###\n\n","completion":"arr = np.array([1,2,3])\nnp.random.choice(arr, size=1) END"}
