{"prompt": "# Make this code more efficient\ndef sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]", "completion": "def partition(array, low, high):\n    pivot = array[high]\n    i = low - 1\n  \n    for j in range(low, high):\n        if array[j] <= pivot:\n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n  \n            # Swapping element at i with element at j\n            (array[i], array[j]) = (array[j], array[i])\n  \n    (array[i + 1], array[high]) = (array[high], array[i + 1])\n  \n    return i + 1\n  \ndef quick_sort(array, low, high):\n    if low < high:\n        pi = partition(array, low, high)\n        quick_sort(array, low, pi - 1)\n        quick_sort(array, pi + 1, high)\n\ndef sort(arr):\n    return quick_sort(array, 0, len(array) - 1)"}
{"prompt": "// Make this code more efficient\nvoid sort(int arr[], int n)\n{\n    int i, j;\n    for (i = 0; i < n - 1; i++)\n \n        // Last i elements are already\n        // in place\n        for (j = 0; j < n - i - 1; j++)\n            if (arr[j] > arr[j + 1])\n                swap(arr[j], arr[j + 1]);\n}", "completion": "void swap(int* a, int* b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n  \n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high]; // pivot\n    int i\n        = (low\n           - 1); // Index of smaller element and indicates\n                 // the right position of pivot found so far\n  \n    for (int j = low; j <= high - 1; j++) {\n        // If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            i++; // increment index of smaller element\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n  \nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high) {\n        /* pi is partitioning index, arr[p] is now\n        at right place */\n        int pi = partition(arr, low, high);\n  \n        // Separately sort elements before\n        // partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid sort(int arr[], int n)\n{\n    quickSort(arr, 0, n - 1);\n}"}
{"prompt": "// Make this code more efficient\nfunction swap(arr, xp, yp)\n{\n    var temp = arr[xp];\n    arr[xp] = arr[yp];\n    arr[yp] = temp;\n}\n \nfunction sort( arr, n)\n{\n    var i, j;\n    for (i = 0; i < n-1; i++)\n    {\n        for (j = 0; j < n-i-1; j++)\n        {\n            if (arr[j] > arr[j+1])\n            {\n            swap(arr,j,j+1);\n            \n            }\n        }\n    \n    }\n}", "completion": "function swap(arr, i, j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction partition(arr, low, high) {\n    let pivot = arr[high];\n    let i = (low - 1);\n  \n    for (let j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i + 1, high);\n    return (i + 1);\n}\n\nfunction quickSort(arr, low, high) {\n    if (low < high) {\n        let pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nfunction sort( arr, n)\n{\n    quickSort(arr, 0, n - 1);\n}"}
{"prompt": "# Make this code more efficient\ndef gradient_descent(x, d, mu, N_epochs):\n    N = len(x)\n    f = 2 / N\n\n    # "Empty" predictions, errors, weights, gradients.\n    y = [0] * N\n    w = [0, 0]\n    grad = [0, 0]\n\n    for _ in it.repeat(None, N_epochs):\n        # Can\"t use a generator because we need to\n        # access its elements twice.\n        err = tuple(i - j for i, j in zip(d, y))\n        grad[0] = f * sum(err)\n        grad[1] = f * sum(i * j for i, j in zip(err, x))\n        w = [i + mu * j for i, j in zip(w, grad)]\n        y = (w[0] + w[1] * i for i in x)\n    return w", "completion": "def gradient_descent(x, d, mu, N_epochs):\n    d = d.squeeze()\n    N = len(x)\n    f = 2 / N\n\n    y = np.zeros(N)\n    err = np.zeros(N)\n    w = np.zeros(2)\n    grad = np.empty(2)\n\n    for _ in it.repeat(None, N_epochs):\n        np.subtract(d, y, out=err)\n        grad[:] = f * np.sum(err), f * (err @ x)\n        w = w + mu * grad\n        y = w[0] + w[1] * x\n    return w"}

